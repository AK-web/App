diff --git a/node_modules/@react-navigation/native/lib/module/findFocusedRouteKey.js b/node_modules/@react-navigation/native/lib/module/findFocusedRouteKey.js
new file mode 100644
index 0000000..f660918
--- /dev/null
+++ b/node_modules/@react-navigation/native/lib/module/findFocusedRouteKey.js
@@ -0,0 +1,6 @@
+import { findFocusedRoute } from '@react-navigation/core';
+export const findFocusedRouteKey = state => {
+    var _findFocusedRoute;
+    // @ts-ignore
+        return (_findFocusedRoute = findFocusedRoute(state)) === null || _findFocusedRoute === void 0 ? void 0 : _findFocusedRoute.key;
+};
diff --git a/node_modules/@react-navigation/native/lib/module/useLinking.js b/node_modules/@react-navigation/native/lib/module/useLinking.js
index d30009f..42da1ab 100644
--- a/node_modules/@react-navigation/native/lib/module/useLinking.js
+++ b/node_modules/@react-navigation/native/lib/module/useLinking.js
@@ -4,6 +4,7 @@ import { findFocusedRoute, getActionFromState as getActionFromStateDefault, getP
 import isEqual from 'fast-deep-equal';
 import * as React from 'react';
 import { createMemoryHistory } from "./createMemoryHistory.js";
+import { findFocusedRouteKey } from './findFocusedRouteKey';
 import { ServerContext } from "./ServerContext.js";
 /**
  * Find the matching navigation state that changed between 2 navigation states
@@ -45,6 +46,44 @@ export const series = cb => {
   return callback;
 };
 const linkingHandlers = [];
+const getAllStateKeys = state => {
+  let current = state;
+  const keys = [];
+  if (current.routes) {
+    for (let route of current.routes) {
+      keys.push(route.key);
+      if (route.state) {
+        // @ts-ignore
+        keys.push(...getAllStateKeys(route.state));
+        }
+      }
+    }
+  return keys;
+};
+const getStaleHistoryDiff = (items, newState) => {
+  const newStateKeys = getAllStateKeys(newState);
+  for (let i = items.length - 1; i >= 0; i--) {
+    const itemFocusedKey = findFocusedRouteKey(items[i].state);
+    if (newStateKeys.includes(itemFocusedKey)) {
+      return items.length - i - 1;
+      }
+    }
+  return -1;
+};
+const getHistoryDeltaByKeys = (focusedState, previousFocusedState) => {
+  const focusedStateKeys = focusedState.routes.map(r => r.key);
+  const previousFocusedStateKeys = previousFocusedState.routes.map(r => r.key);
+  const minLength = Math.min(focusedStateKeys.length, previousFocusedStateKeys.length);
+  let matchingKeys = 0;
+  for (let i = 0; i < minLength; i++) {
+    if (focusedStateKeys[i] === previousFocusedStateKeys[i]) {
+      matchingKeys++;
+      } else {
+      break;
+      }
+    }
+  return -(previousFocusedStateKeys.length - matchingKeys);
+};
 export function useLinking(ref, {
   enabled = true,
   config,
@@ -256,6 +295,9 @@ export function useLinking(ref, {
       // Otherwise it's likely a change triggered by `popstate`
       path !== pendingPath) {
         const historyDelta = (focusedState.history ? focusedState.history.length : focusedState.routes.length) - (previousFocusedState.history ? previousFocusedState.history.length : previousFocusedState.routes.length);
+
+        // The historyDelta and historyDeltaByKeys may differ if the new state has an entry that didn't exist in previous state
+        const historyDeltaByKeys = getHistoryDeltaByKeys(focusedState, previousFocusedState);
         if (historyDelta > 0) {
           // If history length is increased, we should pushState
           // Note that path might not actually change here, for example, drawer open should pushState
@@ -267,7 +309,8 @@ export function useLinking(ref, {
           // If history length is decreased, i.e. entries were removed, we want to go back

           const nextIndex = history.backIndex({
-            path
+            path,
+            state
           });
           const currentIndex = history.index;
           try {
@@ -276,27 +319,42 @@ export function useLinking(ref, {
             history.get(nextIndex)) {
               // An existing entry for this path exists and it's less than current index, go back to that
               await history.go(nextIndex - currentIndex);
+              history.replace({
+                  path,
+                  state
+              });
             } else {
               // We couldn't find an existing entry to go back to, so we'll go back by the delta
               // This won't be correct if multiple routes were pushed in one go before
               // Usually this shouldn't happen and this is a fallback for that
-              await history.go(historyDelta);
+              await history.go(historyDeltaByKeys);
+              if (historyDeltaByKeys + 1 === historyDelta) {
+                  history.push({
+                    path,
+                    state
+                });
+                } else {
+                  history.replace({
+                    path,
+                    state
+                  });
+                }
             }
-
-            // Store the updated state as well as fix the path if incorrect
-            history.replace({
-              path,
-              state
-            });
-          } catch (e) {
-            // The navigation was interrupted
-          }
-        } else {
-          // If history length is unchanged, we want to replaceState
-          history.replace({
-            path,
-            state
-          });
+            // and remove any entries from history which focued route no longer exists in state
+            // That may happen if we replace a whole navigator.
+            const staleHistoryDiff = getStaleHistoryDiff(history.items.slice(0, history.index + 1), state);
+            if (staleHistoryDiff <= 0) {
+              history.replace({
+                path,
+                state
+              });
+              } else {
+                await history.go(-staleHistoryDiff);
+                history.push({
+                  path,
+                  state
+                });
+              }
         }
       } else {
         // If no common navigation state was found, assume it's a replace
diff --git a/node_modules/@react-navigation/native/src/createMemoryHistory.tsx b/node_modules/@react-navigation/native/src/createMemoryHistory.tsx
index 1568263..7d57c39 100644
--- a/node_modules/@react-navigation/native/src/createMemoryHistory.tsx
+++ b/node_modules/@react-navigation/native/src/createMemoryHistory.tsx
@@ -13,7 +13,21 @@ type HistoryRecord = {
 export function createMemoryHistory() {
   let index = 0;
   let items: HistoryRecord[] = [];
-
+  const log = () => {
+    console.log(JSON.stringify({
+      index,
+      indexGetter: history.index,
+      items: items.map((item, i) => {
+        var _item$state;
+        return {
+          selected: history.index === i ? '<<<<<<<' : undefined,
+          path: item.path,
+          id: item.id,
+          state: ((_item$state = item.state) === null || _item$state === void 0 ? void 0 : _item$state.key) || null
+        };
+      })
+    }, null, 4));
+  };
   // Pending callbacks for `history.go(n)`
   // We might modify the callback stored if it was interrupted, so we have a ref to identify it
   const pending: { ref: unknown; cb: (interrupted?: boolean) => void }[] = [];
@@ -29,6 +43,9 @@ export function createMemoryHistory() {
   };

   const history = {
+    get items() {
+      return items;
+    },
     get index(): number {
       // We store an id in the state instead of an index
       // Index could get out of sync with in-memory values if page reloads
@@ -77,6 +94,7 @@ export function createMemoryHistory() {
       // - browsers have limits on how big it can be, and we don't control the size
       // - while not recommended, there could be non-serializable data in state
       window.history.pushState({ id }, '', path);
+      // log();
     },

     replace({ path, state }: { path: string; state: NavigationState }) {
@@ -86,7 +104,7 @@ export function createMemoryHistory() {

       // Need to keep the hash part of the path if there was no previous history entry
       // or the previous history entry had the same path
-      let pathWithHash = path;
+      let pathWithHash = path.replace(/(\/{2,})/g, '/');
       const hash = pathWithHash.includes('#') ? '' : location.hash;

       if (!items.length || items.findIndex((item) => item.id === id) < 0) {
@@ -108,6 +126,7 @@ export function createMemoryHistory() {
       }

       window.history.replaceState({ id }, '', pathWithHash);
+      // log();
     },

     // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
