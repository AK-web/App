import {render, screen, waitFor} from '@testing-library/react-native';
import {Str} from 'expensify-common';
import {Linking} from 'react-native';
import type {OnyxEntry} from 'react-native-onyx';
import Onyx from 'react-native-onyx';
// eslint-disable-next-line no-restricted-imports, no-restricted-syntax
import * as AppActions from '@libs/actions/App';
import {hasAuthToken, signOutAndRedirectToSignIn} from '@libs/actions/Session';
// eslint-disable-next-line no-restricted-imports, no-restricted-syntax
import * as Session from '@libs/actions/Session';
import App from '@src/App';
import CONST from '@src/CONST';
import ONYXKEYS from '@src/ONYXKEYS';
import ROUTES from '@src/ROUTES';
import {createRandomReport} from '../utils/collections/reports';
import * as TestHelper from '../utils/TestHelper';
import waitForBatchedUpdatesWithAct from '../utils/waitForBatchedUpdatesWithAct';
import waitForNetworkPromises from '../utils/waitForNetworkPromises';

const TEST_USER_ACCOUNT_ID_1 = 123;
const TEST_USER_LOGIN_1 = 'test@test.com';
const TEST_AUTH_TOKEN_1 = 'asdfghjkl';

const TEST_USER_ACCOUNT_ID_2 = 456;
const TEST_USER_LOGIN_2 = 'test2@test.com';
const TEST_AUTH_TOKEN_2 = 'zxcvbnm';

jest.setTimeout(60000);
TestHelper.setupApp();
TestHelper.setupGlobalFetchMock();

const report = createRandomReport(7);

function getInitialURL() {
    const params = new URLSearchParams();

    params.set('exitTo', `${ROUTES.REPORT}/${report.reportID}`);
    params.set('email', TEST_USER_LOGIN_1);
    params.set('shortLivedAuthToken', TEST_AUTH_TOKEN_1);

    const deeplinkUrl = `${CONST.DEEPLINK_BASE_URL}/transition?${params.toString()}`;
    return deeplinkUrl;
}

describe('Deep linking', () => {
    let lastVisitedPath: string | undefined;
    let originalSignInWithShortLivedAuthToken: typeof Session.signInWithShortLivedAuthToken;
    let originalOpenApp: typeof AppActions.openApp;

    beforeAll(() => {
        originalSignInWithShortLivedAuthToken = Session.signInWithShortLivedAuthToken;
        originalOpenApp = AppActions.openApp;
    });

    beforeEach(() => {
        Onyx.connect({
            key: ONYXKEYS.LAST_VISITED_PATH,
            callback: (val: OnyxEntry<string>) => (lastVisitedPath = val),
        });

        jest.spyOn(Session, 'signInWithShortLivedAuthToken').mockImplementation(() => {
            Onyx.merge(ONYXKEYS.CREDENTIALS, {
                login: TEST_USER_LOGIN_1,
                autoGeneratedLogin: Str.guid('expensify.cash-'),
                autoGeneratedPassword: Str.guid(),
            });
            Onyx.merge(ONYXKEYS.ACCOUNT, {
                validated: true,
                isUsingExpensifyCard: false,
            });
            Onyx.merge(ONYXKEYS.PERSONAL_DETAILS_LIST, {
                [TEST_USER_ACCOUNT_ID_1]: TestHelper.buildPersonalDetails(TEST_USER_LOGIN_1, TEST_USER_ACCOUNT_ID_1, 'Test'),
            });
            Onyx.merge(ONYXKEYS.SESSION, {
                authToken: TEST_AUTH_TOKEN_1,
                accountID: TEST_USER_ACCOUNT_ID_1,
                email: TEST_USER_LOGIN_1,
                encryptedAuthToken: TEST_AUTH_TOKEN_1,
            });
            Onyx.merge(ONYXKEYS.NVP_PRIVATE_PUSH_NOTIFICATION_ID, 'randomID');

            return originalSignInWithShortLivedAuthToken(TEST_AUTH_TOKEN_1);
        });

        jest.spyOn(AppActions, 'openApp').mockImplementation(async () => {
            await Onyx.set(`${ONYXKEYS.COLLECTION.REPORT}${report.reportID}`, report);
            return originalOpenApp();
        });
    });

    afterEach(async () => {
        await Onyx.clear();
        await waitForNetworkPromises();
        jest.clearAllMocks();
        lastVisitedPath = undefined;
    });

    it('should not reuse the last deep link and log in when signing out', async () => {
        expect(hasAuthToken()).toBe(false);

        const cleanUpSpy = jest.spyOn(Session, 'cleanupSession');
        const url = getInitialURL();

        await TestHelper.signInWithTestUser(TEST_USER_ACCOUNT_ID_2, TEST_USER_LOGIN_2, undefined, TEST_AUTH_TOKEN_2);
        Linking.setInitialURL(url);

        await waitForBatchedUpdatesWithAct();

        render(<App />);

        await waitForBatchedUpdatesWithAct();

        expect(hasAuthToken()).toBe(true);

        await waitForBatchedUpdatesWithAct();

        // Verify the current page is the report in the deep link
        await waitFor(() => {
            expect(screen.getByText(report.reportName ?? ''));
        });
        await waitFor(() => {
            expect(lastVisitedPath).toBe(`/${ROUTES.REPORT}/${report.reportID}`);
        });

        signOutAndRedirectToSignIn();

        await waitForBatchedUpdatesWithAct();

        await waitFor(() => {
            expect(hasAuthToken()).toBe(false);
        });

        await waitFor(() => {
            // 1. Initial sign out from deep link transition
            // 2. signOutAndRedirectToSignIn call
            expect(cleanUpSpy).toHaveBeenCalledTimes(2);
        });

        cleanUpSpy.mockClear();
    });

    it('should not remember the report path of the last deep link login after signing out and in again', async () => {
        expect(hasAuthToken()).toBe(false);

        const url = getInitialURL();
        Linking.setInitialURL(url);

        render(<App />);

        await waitForBatchedUpdatesWithAct();

        expect(lastVisitedPath).toBe(`/${ROUTES.REPORT}/${report.reportID}`);

        expect(hasAuthToken()).toBe(true);

        signOutAndRedirectToSignIn();

        await waitForBatchedUpdatesWithAct();

        expect(hasAuthToken()).toBe(false);

        await TestHelper.signInWithTestUser(TEST_USER_ACCOUNT_ID_2, TEST_USER_LOGIN_2, undefined, TEST_AUTH_TOKEN_2);

        await waitForBatchedUpdatesWithAct();

        expect(lastVisitedPath).toBeDefined();
        expect(lastVisitedPath).not.toBe(`/${ROUTES.REPORT}/${report.reportID}`);
    });
});
